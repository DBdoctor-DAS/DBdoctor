# 端午特别篇：你真的了解数据库索引吗？
DBdoctor 2月份正式对外推出索引推荐功能，此功能实际在公司已运行一年多，内部数万实例每月会产生大量的待优化SQL，DBdoctor会持续跟踪优化结果，并对结果进行优化前后的性能对比，定期产出对比报告。我们的工程师会仔细分析报告，关注推荐应用率和推荐准确率，从而做到持续优化，形成闭环。

在分析推荐结果时，会时不时遇到一些颠覆我们认知的推荐，从而产生了自我怀疑，我们真的会创建索引吗？

下面用一个MySQL8.0的例子，带大家一起看看是不是颠覆认知。

## 具体例子

```SQL
select *
from
  device
where
  purchase_data>='2023-05-31'
  and status='inactive' 
  and device_id>0
  and device_name like '%162b%';
```

以上SQL，数据量在1000万行多一点，SQL比较简单，大家能对业务猜的八九不离十，正是我们的线上业务。一个设备表，有购买、激活、ID、名称等字段。业务想看下从2023-05-31到现在还没激活的某类设备。

老司机们看到以上SQL，该如何创建索引？

以下是通过GPT生成的联合索引使用规则，大体上符合大家的认知：

```
最左前缀原则：查询条件中使用了联合索引的第一个字段或者是前几个字段，索引会被使用。
不需要按索引中的顺序使用所有字段：可以跳过某些字段，只要保证最左边的字段被使用。
不精确匹配：如果查询条件中不是对联合索引的全部字段进行等值比较，则只有最后一个字段可以进行范围查询（比如使用 >, <, >=, <=），前面所有字段必须进行等值匹配。
```

个人解读：

- device_id看起来是个不错的字段，但是条件是>0，看起来是只为了过滤些非正常数据，应该一般。

- purchase_data看起来不错，时间是2023年5月，离现在还算比较近。

- status一看就不怎样，但是value是inactive，毕竟买了不激活的是少数。

- 再加上以上联合索引的创建规则，要么我会建purchase_data单个索引，要么创建(status、purchase_data)的联合索引。

## DBdoctor推荐
下面来看下DBdoctor的索引推荐是怎么推荐的，了解DBdoctor的小伙伴应该知道，DBdoctor是基于外置COST优化器，通过采集真实数据情况进行计算，最终得出不同索引的COST消耗排序，推荐COST最小的索引。按照这个原理，DBdoctor推荐出的索引跟内核真实是最接近的。目前此功能除了自动发现慢SQL并触发索引推荐外，还应用在SQL审核中，可以在SQL上线前进行审核SQL性能问题，并给出优化建议。所以，只需要把SQL贴在SQL审核里进行审核，就能查看到推荐结果。

![](https://mmbiz.qpic.cn/mmbiz_png/dFRFrFfpIZmS7eht6cbb1icSWkyeCtM1Chrx04vC6TcEcymh80RyJquq9Iv95mDW8QGaQISiaybYy0K9PWBM4Haw/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

以上推荐的结果令人大跌眼镜，竟然推了一个(status,purchase_date,device_name,device_id) 的一个联合索引？

关键是这个索引超出了我们的认知，第二个字段是范围查询，第三个字段是左右模糊查询，这个字段跟我个人解读中要建的(status,purchase_data)性能上有区别吗？性能如果没区别，还占用了空间，是不是内核也有打盹的时候？

**验证步骤1：**

在实例上真实创建(status,purchase_data)索引，执行以上SQL 5次，查看执行耗时。结果基本在800ms左右。

**验证步骤2：**

在实例上真实创建(status,purchase_date,device_name,device_id)索引，通过explain，查看到底走哪个索引。结果竟然真是走推荐的索引。

**验证步骤3：**

在实例上再次执行以上SQL 5次，查看执行耗时。结果基本在710ms左右，虽然快了不多，但是确实是快。

**通过以上3个步骤做下来，发现确实会优先走推荐的索引，且性能最佳。**

## 总结

1. 业界也有索引推荐的相关产品，几乎都是通过规则方法实现，通过规则准确吗？

2. 相同的结果，不同的数据，会让执行计划产生差异，业务开发或者DBA真的了解业务的数据情况吗？规则会考虑到数据情况吗？

3. 知道以上结果的原理的小伙伴可以评论区留言哦，欢迎大家关注公众号，后续会解读原因。

真正了解您数据库的，不是您本人，是存着您数据的数据库自身，现在又多了一位DBdoctor，赶快下载使用吧！