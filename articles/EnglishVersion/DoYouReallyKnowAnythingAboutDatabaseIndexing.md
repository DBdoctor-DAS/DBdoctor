# Dragon Boat Festival Special Edition: Do You Really Understand Database Indexing?
DBdoctor officially launched the index recommendation function in February. This function has been running in the company for more than a year. Tens of thousands of internal instances generate a large amount of SQL to be optimized every month. DBdoctor will continue to track the optimization results, compare the performance before and after optimization, and regularly produce comparison reports. Our engineers will carefully analyze the reports, pay attention to the recommendation application rate and accuracy, so as to achieve continuous optimization and form a closed loop.

When analyzing recommendation results, we occasionally encounter recommendations that subvert our cognition, which leads to self-doubt. Will we really create an index?

Below is an example of MySQL 8.0 to show everyone whether it subverts cognition.

## Specific example

```SQL
select *
from
  device
where
  purchase_data>='2023-05-31'
  and status='inactive' 
  and device_id>0
  and device_name like '%162b%';
```

Above SQL, the amount of data is a little more than 10 million lines, SQL is relatively simple, everyone can guess the business about eight or nine out of ten, it is our online business. A device table, there are purchase, activation, ID, name and other fields. The business wants to see a certain type of device that has not been activated from 2023-05-31 to now.

Experienced drivers see the above SQL, how to create an index?

The following are the rules for using joint indexes generated by GPT, which generally conform to everyone's understanding.

```
The leftmost prefix principle: If the query condition uses the first field or the first few fields of the joint index, the index will be used.
It is not necessary to use all fields in the order in the index: some fields can be skipped as long as the leftmost field is used.
Inexact match: If the query condition does not compare all fields of the joint index equally, only the last field can be used for range query (such as using >, <, >=, <=）， all fields before must be matched equally.
```

Personal interpretation:

- device_id looks like a good field, but the condition is > 0, it seems to be just to filter some abnormal data, it should be general.

- purchase_data looks good, the time is May 2023, which is relatively close to now.

- The status doesn't look good at first glance, but the value is inactive. After all, only a few people buy it but don't activate it.

- In addition to the above joint index creation rules, either I will create purchase_data single index or create a joint index of (status, purchase_data).

## DBdoctor recommended
Let's take a look at how DBdoctor recommends indexes. Those who are familiar with DBdoctor should know that DBdoctor is based on an external COST optimizer, which calculates the COST consumption ranking of different indexes by collecting real data, and recommends the index with the smallest COST. According to this principle, the index recommended by DBdoctor is closest to the kernel. Currently, this function not only automatically detects slow SQL and triggers index recommendation, but also applies to SQL auditing. It can audit SQL performance issues before SQL goes online and provide optimization suggestions. Therefore, you only need to paste SQL into SQL auditing for auditing to see the recommended results.

![](https://mmbiz.qpic.cn/mmbiz_png/dFRFrFfpIZmS7eht6cbb1icSWkyeCtM1Chrx04vC6TcEcymh80RyJquq9Iv95mDW8QGaQISiaybYy0K9PWBM4Haw/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

The above recommended results are surprising, and a joint index of (status, purchase_date, device_name, device_id) has been pushed?

The key is that this index is beyond our understanding. The second field is a range query, and the third field is a left and right fuzzy query. Is there any difference in performance between this field and the (status, purchase_data) to be built in my personal interpretation? If there is no difference in performance, it also occupies space. Does the kernel also have naps?

**Verification step 1：**

Create a real (status, purchase_data) index on the instance, execute the above SQL 5 times, and check the execution time. The result is basically around 800ms.

**Verification step 2:**

Create a real (status, purchase_date, device_name, device_id) index on the instance, and check which index to use through explain. The result is actually the recommended index.

**Verification step 3:**

Execute the above SQL 5 times on the instance and check the execution time. The result is basically around 710ms, although not much faster, it is indeed fast.

**After following the above three steps, it was found that the recommended index is indeed prioritized and has the best performance.**

## Summary

1. There are also related products recommended by indexing in the industry, almost all of which are realized through the rule method. Is the rule accurate?

2. The same result, different data, will make the execution plan different. Do business developers or DBAs really understand the data situation of the business? Will the rules take into account the data situation?

3. Those who know the principle of the above results can leave a comment in the comment area. Welcome to pay attention to the official account. The reasons will be explained later.

The one who truly understands your database is not you, but the database itself that stores your data. Now there is another DBdoctor, download and use it quickly!